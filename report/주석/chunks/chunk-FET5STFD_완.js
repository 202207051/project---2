// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 3759d569955c51a9 "Perform (copy)", do not edit manually */

// /:https://framerusercontent.com/modules/zvkTOpMSuRzRhLzZZIwG/yCImoe7N6FDrwtjU8MPe/SlideShow.js
// 메인 슬라이드쇼 컴포넌트 로직

import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { resize } from "@motionone/dom";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
// Framer 컴포넌트 제어 및 렌더링 환경 설정을 위한 유틸리티를 가져옵니다.

import { animate, LayoutGroup, mix, motion, frame, useInView, useMotionValue, useTransform, wrap, usePageInView } from "unframer";
// Framer Motion (애니메이션), 레이아웃 관리, 뷰포트 감지, 모션 값 관리 등의 핵심 기능을 가져옵니다.

import { Children, cloneElement, forwardRef, memo, startTransition, useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
// React 기본 훅과 유틸리티를 가져옵니다.

function awaitRefCallback(element, controller) {
// React Ref가 비동기적으로 설정될 때까지 기다리는 헬퍼 함수입니다.
  let refCallbackResolve;
  let current = element.current;
  Object.defineProperty(element, "current", { get() {
    return current;
  }, set(node) {
    current = node;
    if (node === null) {
      controller.abort();
      return;
    }
    refCallbackResolve?.(node);
  }, configurable: true });
  if (current) return current;
  const refCallbackPromise = new Promise((resolve, reject) => {
    refCallbackResolve = resolve;
    controller.signal.addEventListener("abort", reject);
  }).catch(() => {
  });
  return refCallbackPromise;
}
var OPACITY_0 = 1e-3; // 0 대신 0.001을 사용하여 애니메이션 최적화/가시성 트릭을 수행합니다.

function Slideshow(props) {
  const { slots = [], startFrom, direction, effectsOptions, autoPlayControl, dragControl, alignment, gap, padding, paddingPerSide, paddingTop, paddingRight, paddingBottom, paddingLeft, itemAmount, fadeOptions, intervalControl, transitionControl, arrowOptions, borderRadius, progressOptions, style } = props;
// 컴포넌트의 모든 속성(props)을 분해합니다.

  const { effectsOpacity, effectsScale, effectsRotate, effectsPerspective, effectsHover, playOffscreen } = effectsOptions;
  const { fadeContent, overflow, fadeWidth, fadeInset, fadeAlpha } = fadeOptions;
  const { showMouseControls, arrowSize, arrowRadius, arrowFill, leftArrow, rightArrow, arrowShouldSpace = true, arrowShouldFadeIn = false, arrowPosition, arrowPadding, arrowGap, arrowPaddingTop, arrowPaddingRight, arrowPaddingBottom, arrowPaddingLeft } = arrowOptions;
  const { showProgressDots, dotSize, dotsInset, dotsRadius, dotsPadding, dotsGap, dotsFill, dotsBackground, dotsActiveOpacity, dotsOpacity, dotsBlur } = progressOptions;
// 옵션 객체에서 하위 속성들을 분해합니다.

  const paddingValue = paddingPerSide ? `${paddingTop}px ${paddingRight}px ${paddingBottom}px ${paddingLeft}px` : `${padding}px`;
// CSS 패딩 값을 계산합니다.

  const isCanvas = RenderTarget.current() === RenderTarget.canvas;
// Framer 캔버스 에디터에서 실행 중인지 확인합니다.

  const filteredSlots = slots.filter(Boolean);
  const amountChildren = Children.count(filteredSlots);
  const hasChildren = amountChildren > 0;

  if (!hasChildren) {
    return /* @__PURE__ */ _jsxs("section", { style: placeholderStyles, children: [/* @__PURE__ */ _jsx("div", { style: emojiStyles, children: "\u2B50\uFE0F" }), /* @__PURE__ */ _jsx("p", { style: titleStyles, children: "Connect to Content" }), /* @PURE__ */ _jsx("p", { style: subtitleStyles, children: "Add layers or components to make infinite auto-playing slideshows." })] });
  }
// 자식이 없을 경우 플레이스홀더를 렌더링합니다.

  const parentRef = useRef(null); // 슬라이드 컨테이너(ul)의 Ref
  const childrenRef = useMemo(() => {
    return [{ current: null }, { current: null }];
  }, [filteredSlots]);
// 슬라이드 크기 측정을 위해 첫 번째와 마지막 자식 요소의 Ref를 저장합니다.

  const timeoutRef = useRef(void 0); // 자동 재생 타이머 Ref
  const [size, setSize] = useState({ parent: null, children: null, item: null, itemWidth: null, itemHeight: null, viewportLength: null });
// 컨테이너 및 아이템의 크기 정보를 저장하는 상태입니다.

  const writingDirection = useWritingDirection(); // 쓰기 방향 (ltr/rtl)을 가져옵니다.
  const resolvedDirection = getSlideshowResolvedDirection(direction, writingDirection); // 쓰기 방향에 따라 슬라이드 방향을 조정합니다.
  const isHorizontal = resolvedDirection === "left" || resolvedDirection === "right"; // 수평 슬라이드 여부
  const isInverted = resolvedDirection === "right" || resolvedDirection === "bottom"; // 방향이 오른쪽/아래쪽(역방향)인지 여부
  const rtlDirectionModifier = isHorizontal && writingDirection === "rtl" ? -1 : 1; // RTL일 경우 방향 보정 값입니다.

  const [isHovering, setIsHovering] = useState(false);
  const [shouldPlayOnHover, setShouldPlayOnHover] = useState(autoPlayControl);
  const [isMouseDown, setIsMouseDown] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
// 호버, 마우스 다운, 리사이징 상태를 관리합니다.

  let dupedChildren = [];
  let duplicateBy = 4; // 무한 슬라이드를 위해 콘텐츠를 4번 복제합니다.
  if (isCanvas) {
    duplicateBy = 1; // 캔버스에서는 복제하지 않습니다.
  }
  const measure = useCallback(() => {
    if (!parentRef.current) return;
    const isRTL = isHorizontal && childrenRef[0].current && childrenRef[1].current && childrenRef[1].current.offsetLeft < childrenRef[0].current.offsetLeft;
    const firstChild = isRTL ? childrenRef[1].current : childrenRef[0].current;
    const lastChild = isRTL ? childrenRef[0].current : childrenRef[1].current;
    const parentLength = isHorizontal ? parentRef.current.offsetWidth : parentRef.current.offsetHeight;
    const start = firstChild ? isHorizontal ? firstChild.offsetLeft : firstChild.offsetTop : 0;
    const end = lastChild ? isHorizontal ? lastChild.offsetLeft + lastChild.offsetWidth : lastChild.offsetTop + lastChild.offsetHeight : 0;
    const childrenLength = end - start + gap; // 복제된 모든 자식 요소의 총 길이 (gap 포함)
    const itemSize = firstChild ? isHorizontal ? firstChild.offsetWidth : firstChild.offsetHeight : 0; // 단일 아이템의 크기
    const itemWidth = firstChild ? firstChild.offsetWidth : 0;
    const itemHeight = firstChild ? firstChild.offsetHeight : 0;
    const viewportLength = isHorizontal ? Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0, parentRef.current.offsetWidth) : Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0, parentRef.current.offsetHeight);
    setSize({ parent: parentLength, children: childrenLength, item: itemSize, itemWidth, itemHeight, viewportLength });
  }, []);
// 컴포넌트와 자식 요소들의 크기를 측정하는 함수입니다. 무한 루프 계산의 핵심입니다.

  const scheduleMeasure = useCallback(async () => {
    const controller = new AbortController();
    const [firstChild, lastChild] = childrenRef;
    if (!isCanvas && (!firstChild.current || !lastChild.current)) try {
      await Promise.all([awaitRefCallback(firstChild, controller), amountChildren > 1 ? awaitRefCallback(lastChild, controller) : true]);
    } catch {
      controller.abort();
    }
    frame.read(measure, false, true); // Framer의 프레임 읽기 사이클에 측정 함수를 예약합니다.
  }, [measure]);

  useLayoutEffect(() => {
    scheduleMeasure();
  }, [itemAmount]);
// 레이아웃이 변경되면 크기 측정을 다시 수행합니다.

  const initialResize = useRef(true);
  useEffect(() => {
    return resize(parentRef.current, ({ contentSize }) => {
      if (!initialResize.current && (contentSize.width || contentSize.height)) {
        scheduleMeasure();
        startTransition(() => setIsResizing(true));
      }
      initialResize.current = false;
    });
  }, []);
// 부모 컨테이너 크기 변경(resize)을 감지하고 재측정을 예약합니다.

  useEffect(() => {
    if (isResizing) {
      const timer = setTimeout(() => startTransition(() => setIsResizing(false)), 500);
      return () => clearTimeout(timer);
    }
  }, [isResizing]);
// 리사이징이 완료된 후 500ms가 지나면 리사이징 상태를 해제합니다.

  const totalItems = filteredSlots?.length;
  const childrenSize = isCanvas ? 0 : size?.children; // 복제된 모든 슬라이드의 총 길이
  const itemWithGap = size?.item + gap; // 단일 슬라이드 + 갭
  const itemOffset = startFrom * itemWithGap; // 시작 오프셋
  const [currentItem, setCurrentItem] = useState(startFrom + totalItems); // 현재 페이지 인덱스 (무한 루프 처리를 위해 totalItems만큼 더해서 시작)

  const [isDragging, setIsDragging] = useState(false);
  if (isCanvas) {
    if (currentItem !== startFrom) {
      setCurrentItem(startFrom);
    }
  }
// 캔버스 모드에서는 드래깅 상태 및 currentItem을 재설정합니다.

  const visibilityRef = useRef(null);
  const isInView = useInView(visibilityRef); // Framer Motion 훅: 요소가 뷰포트 내에 있는지 확인
  const isVisible = usePageInView() && isInView; // 페이지가 보이는 상태 + 요소가 뷰포트 내에 있는지 확인

  const factor = isInverted ? 1 : -1; // 방향 계수 (정방향/역방향)
  const xOrY = useMotionValue(childrenSize); // 애니메이션을 위한 모션 값 (x 또는 y 위치)

  const canvasPosition = isHorizontal ? -startFrom * (size?.itemWidth + gap) : -startFrom * (size?.itemHeight + gap);
  const newPosition = () => factor * currentItem * itemWithGap;
// 애니메이션 목표 위치 계산 함수입니다. (현재 아이템 * 아이템 너비/높이)

  const wrappedValue = !isCanvas ? useTransform(xOrY, (value) => {
    const wrapped = wrap(-childrenSize * rtlDirectionModifier, -childrenSize * rtlDirectionModifier * 2, value * rtlDirectionModifier);
    return isNaN(wrapped) ? 0 : wrapped;
  }) : 0;
// 핵심 무한 루프 로직: 모션 값을 슬라이드 컨테이너의 총 길이 내로 래핑하여 애니메이션이 끊김 없이 순환하도록 만듭니다.

  const wrappedIndex = wrap(0, totalItems, currentItem); // 0부터 totalItems-1 사이의 인덱스로 래핑 (닷 네비게이션용)
  const wrappedIndexInverted = wrap(0, -totalItems, currentItem); // 역방향 래핑

  useLayoutEffect(() => {
    if (size?.children === null) return;
    if (!initialResize.current && isResizing) {
      xOrY.set(newPosition()); // 리사이징 중이면 위치를 즉시 새 포지션으로 설정하여 깜박임을 방지합니다.
    }
  }, [size, childrenSize, factor, itemOffset, currentItem, itemWithGap, isResizing]);
// 레이아웃 변경 또는 리사이징 시 위치를 동기화합니다.

  const switchPages = () => {
    if (isCanvas || !hasChildren || !size.parent || isDragging) return;
    if (xOrY.get() !== newPosition()) {
      animate(xOrY, newPosition(), transitionControl); // 목표 위치로 애니메이션을 실행합니다.
    }
    if (autoPlayControl && shouldPlayOnHover && (playOffscreen || isVisible)) {
      timeoutRef.current = setTimeout(() => {
        startTransition(() => setCurrentItem((item) => item + 1 * rtlDirectionModifier));
        switchPages();
      }, intervalControl * 1e3); // 지정된 간격(intervalControl) 후 다음 아이템으로 전환
    }
  };

  const setDelta = (delta, transition = false) => {
    if (!isInverted) {
      if (transition) startTransition(() => setCurrentItem((item) => item + delta));
      else setCurrentItem((item) => item + delta);
    } else {
      if (transition) startTransition(() => setCurrentItem((item) => item - delta));
      else setCurrentItem((item) => item - delta);
    }
  };
// 현재 페이지에서 delta만큼 페이지를 이동시키는 함수입니다. (화살표 버튼 사용)

  const setPage = (index) => {
    const currentItemWrapped = wrap(0, totalItems, currentItem);
    const currentItemWrappedInvert = wrap(0, -totalItems, currentItem);
    const goto = index - currentItemWrapped;
    const gotoInverted = index - Math.abs(currentItemWrappedInvert);
    if (!isInverted) {
      startTransition(() => setCurrentItem((item) => item + goto));
    } else {
      startTransition(() => setCurrentItem((item) => item - gotoInverted));
    }
  };
// 특정 페이지(index)로 바로 이동시키는 함수입니다. (닷 네비게이션 사용)

  const handleDragStart = () => {
    startTransition(() => setIsDragging(true));
  };

  const handleDragEnd = (event, { offset, velocity }) => {
    startTransition(() => setIsDragging(false));
    const offsetXorY = isHorizontal ? offset.x : offset.y;
    const velocityThreshold = 200;
    const velocityXorY = isHorizontal ? velocity.x : velocity.y;
    const isHalfOfNext = offsetXorY < -size.item / 2;
    const isHalfOfPrev = offsetXorY > size.item / 2;
    const normalizedOffset = Math.abs(offsetXorY);
    const itemDelta = Math.round(normalizedOffset / size.item);
    const itemDeltaFromOne = itemDelta === 0 ? 1 : itemDelta;
// 드래그가 끝났을 때, 오프셋과 속도(velocity)를 기준으로 다음 페이지로 이동할지 결정하는 로직입니다.
    if (velocityXorY > velocityThreshold) {
      setDelta(-itemDeltaFromOne * rtlDirectionModifier, true);
    } else if (velocityXorY < -velocityThreshold) {
      setDelta(itemDeltaFromOne * rtlDirectionModifier, true);
    } else {
      if (isHalfOfNext) {
        setDelta(itemDelta * rtlDirectionModifier, true);
      }
      if (isHalfOfPrev) {
        setDelta(-itemDelta * rtlDirectionModifier, true);
      }
    }
  };

  useEffect(() => {
    if (!isVisible || isResizing || amountChildren <= 1) return;
    switchPages(); // 컴포넌트가 보이고 리사이징 중이 아닐 때 자동 재생을 시작합니다.
    return () => timeoutRef.current && clearTimeout(timeoutRef.current);
  }, [dupedChildren, isVisible, isResizing]);
// 자동 재생 로직을 처리하는 useEffect입니다.

  let childCounter = 0;
  const columnOrRowValue = `calc(${100 / itemAmount}% - ${gap}px + ${gap / itemAmount}px)`;
// CSS flexbox/grid 크기 계산 (아이템 개수와 간격 반영)

  for (let index = 0; index < duplicateBy; index++) {
    dupedChildren = dupedChildren.concat(Children.map(filteredSlots, (child, childIndex) => {
      let ref;
      if (index === 0) {
        if (childIndex === 0) {
          ref = childrenRef[0];
        } else if (childIndex === filteredSlots.length - 1) {
          ref = childrenRef[1];
        }
      }
      return /* @__PURE__ */ _jsx(Slide, { ref, slideKey: index + childIndex + "lg", index, width: isHorizontal ? itemAmount > 1 ? columnOrRowValue : "100%" : "100%", height: !isHorizontal ? itemAmount > 1 ? columnOrRowValue : "100%" : "100%", size, child, numChildren: filteredSlots?.length, wrappedValue, childCounter: childCounter++, gap, isCanvas, isHorizontal, effectsOpacity, effectsScale, effectsRotate, directionModifier: rtlDirectionModifier, children: index + childIndex }, index + childIndex + "lg");
    }));
  }
// 슬롯에 있는 자식 컴포넌트들을 복제(`duplicateBy` 횟수)하고 `Slide` 컴포넌트로 래핑합니다.

  const fadeDirection = isHorizontal ? "to right" : "to bottom";
  const fadeWidthStart = fadeWidth / 2;
  const fadeWidthEnd = 100 - fadeWidth / 2;
  const fadeInsetStart = clamp(fadeInset, 0, fadeWidthStart);
  const fadeInsetEnd = 100 - fadeInset;
  const fadeMask = `linear-gradient(${fadeDirection}, rgba(0, 0, 0, ${fadeAlpha}) ${fadeInsetStart}%, rgba(0, 0, 0, 1) ${fadeWidthStart}%, rgba(0, 0, 0, 1) ${fadeWidthEnd}%, rgba(0, 0, 0, ${fadeAlpha}) ${fadeInsetEnd}%)`;
// 슬라이드 콘텐츠의 가장자리를 부드럽게 페이드 아웃시키는 CSS 마스크(linear-gradient)를 계산합니다. (Clipping 옵션)

  const dots = [];
  const dotsBlurStyle = {};
  if (showProgressDots) {
    for (let i = 0; i < filteredSlots?.length; i++) {
      dots.push(/* @__PURE__ */ _jsx(Dot, { dotStyle: { ...dotStyle, width: dotSize, height: dotSize, backgroundColor: dotsFill }, buttonStyle: baseButtonStyles, selectedOpacity: dotsActiveOpacity, opacity: dotsOpacity, onClick: () => setPage(i), wrappedIndex, wrappedIndexInverted, total: totalItems, index: i, gap: dotsGap, padding: dotsPadding, isHorizontal, isInverted }, i));
    }
    if (dotsBlur > 0) {
      dotsBlurStyle.backdropFilter = dotsBlurStyle.WebkitBackdropFilter = `blur(${dotsBlur}px)`;
    }
  }
// 페이지네이션 점(Dot)들을 생성하고 스타일을 적용합니다.

  const dragProps = dragControl ? { drag: isHorizontal ? "x" : "y", onDragStart: handleDragStart, onDragEnd: handleDragEnd, dragDirectionLock: true, values: { x: writingDirection === "rtl" ? -xOrY : xOrY, y: xOrY }, dragMomentum: false } : {};
// 드래그 제어가 활성화된 경우 Framer Motion의 드래그 관련 속성(props)을 정의합니다.

// 화살표 위치 설정을 위한 조건부 변수들입니다.
  const arrowHasTop = arrowPosition === "top-left" || arrowPosition === "top-mid" || arrowPosition === "top-right";
  const arrowHasBottom = arrowPosition === "bottom-left" || arrowPosition === "bottom-mid" || arrowPosition === "bottom-right";
  const arrowHasLeft = arrowPosition === "top-left" || arrowPosition === "bottom-left";
  const arrowHasRight = arrowPosition === "top-right" || arrowPosition === "bottom-right";
  const arrowHasMid = arrowPosition === "top-mid" || arrowPosition === "bottom-mid" || arrowPosition === "auto";
  const leftArrowSrc = leftArrow || "https://framerusercontent.com/images/6tTbkXggWgQCAJ4DO2QEdXXmgM.svg?arrow=left";
  const rightArrowSrc = rightArrow || "https://framerusercontent.com/images/11KSGbIZoRSg4pjdnUoif6MKHI.svg?arrow=right";

  return /* @__PURE__ */ _jsxs("section", { style: { ...containerStyle, padding: paddingValue, WebkitMaskImage: fadeContent ? fadeMask : void 0, maskImage: fadeContent ? fadeMask : void 0, opacity: size?.item !== null ? 1 : OPACITY_0, userSelect: "none" }, onMouseEnter: () => {
    setIsHovering(true);
    if (!effectsHover) setShouldPlayOnHover(false);
  }, onMouseLeave: () => {
    setIsHovering(false);
    if (!effectsHover) setShouldPlayOnHover(true);
  }, onMouseDown: (event) => {
    event.preventDefault();
    startTransition(() => setIsMouseDown(true));
  }, onMouseUp: () => startTransition(() => setIsMouseDown(false)), ref: visibilityRef, children: [/* @__PURE__ */ _jsx("div", { style: { width: "100%", height: "100%", margin: 0, padding: "inherit", position: "absolute", inset: 0, overflow: overflow ? "visible" : "hidden", borderRadius, userSelect: "none", perspective: isCanvas ? "none" : effectsPerspective }, children: /* @__PURE__ */ _jsx(motion.ul, { ref: parentRef, ...dragProps, style: { ...containerStyle, gap, placeItems: alignment, x: isHorizontal ? isCanvas ? canvasPosition : wrappedValue : 0, y: !isHorizontal ? isCanvas ? canvasPosition : wrappedValue : 0, flexDirection: isHorizontal ? "row" : "column", transformStyle: effectsRotate !== 0 && !isCanvas ? "preserve-3d" : void 0, cursor: dragControl ? isMouseDown ? "grabbing" : "grab" : "auto", userSelect: "none", ...style }, children: dupedChildren }) }), /* @__PURE__ */ _jsxs("fieldset", { style: { ...controlsStyles }, "aria-label": "Slideshow pagination controls", className: "framer--slideshow-controls", children: [/* @__PURE__ */ _jsxs(motion.div, { style: { position: "absolute", display: "flex", flexDirection: isHorizontal ? "row" : "column", justifyContent: arrowShouldSpace ? "space-between" : "center", gap: arrowShouldSpace ? "unset" : arrowGap, opacity: arrowShouldFadeIn ? OPACITY_0 : 1, alignItems: "center", inset: arrowPadding, top: arrowShouldSpace ? arrowPadding : arrowHasTop ? arrowPaddingTop : "unset", left: arrowShouldSpace ? arrowPadding : arrowHasLeft ? arrowPaddingLeft : arrowHasMid ? 0 : "unset", right: arrowShouldSpace ? arrowPadding : arrowHasRight ? arrowPaddingRight : arrowHasMid ? 0 : "unset", bottom: arrowShouldSpace ? arrowPadding : arrowHasBottom ? arrowPaddingBottom : "unset" }, animate: arrowShouldFadeIn && { opacity: isHovering ? 1 : OPACITY_0 }, transition: transitionControl, children: [/* @__PURE__ */ _jsx(motion.button, { type: "button", style: { ...baseButtonStyles, backgroundColor: arrowFill, width: arrowSize, height: arrowSize, borderRadius: arrowRadius, rotate: !isHorizontal ? 90 : 0, display: showMouseControls ? "block" : "none", pointerEvents: "auto" }, onClick: () => setDelta(-1, true), "aria-label": "Previous", whileTap: { scale: 0.9 }, transition: { duration: 0.15 }, children: /* @__PURE__ */ _jsx("img", { decoding: "async", width: arrowSize, height: arrowSize, src: isHorizontal && writingDirection === "rtl" ? rightArrowSrc : leftArrowSrc, alt: "Back Arrow" }) }), /* @__PURE__ */ _jsx(motion.button, { type: "button", style: { ...baseButtonStyles, backgroundColor: arrowFill, width: arrowSize, height: arrowSize, borderRadius: arrowRadius, rotate: !isHorizontal ? 90 : 0, display: showMouseControls ? "block" : "none", pointerEvents: "auto" }, onClick: () => setDelta(1, true), "aria-label": "Next", whileTap: { scale: 0.9 }, transition: { duration: 0.15 }, children: /* @__PURE__ */ _jsx("img", { decoding: "async", width: arrowSize, height: arrowSize, src: isHorizontal && writingDirection === "rtl" ? leftArrowSrc : rightArrowSrc, alt: "Next Arrow" }) })] }), dots.length > 1 ? /* @__PURE__ */ _jsx("div", { style: { ...dotsContainerStyle, left: isHorizontal ? "50%" : dotsInset, top: !isHorizontal ? "50%" : "unset", transform: isHorizontal ? "translateX(-50%)" : "translateY(-50%)", flexDirection: isHorizontal ? "row" : "column", bottom: isHorizontal ? dotsInset : "unset", borderRadius: dotsRadius, backgroundColor: dotsBackground, userSelect: "none", ...dotsBlurStyle }, children: dots }) : null] })] });
// 메인 렌더링 부분: 슬라이드 컨테이너(motion.ul)와 컨트롤(화살표, 닷)을 렌더링합니다.

}
Slideshow.defaultProps = { direction: "left", dragControl: false, startFrom: 0, itemAmount: 1, infinity: true, gap: 10, padding: 10, autoPlayControl: true, effectsOptions: { effectsOpacity: 1, effectsScale: 1, effectsRotate: 0, effectsPerspective: 1200, effectsHover: true, playOffscreen: false }, transitionControl: { type: "spring", stiffness: 200, damping: 40 }, fadeOptions: { fadeContent: false, overflow: false, fadeWidth: 25, fadeAlpha: 0, fadeInset: 0 }, arrowOptions: { showMouseControls: true, arrowShouldFadeIn: false, arrowShouldSpace: true, arrowFill: "rgba(0,0,0,0.2)", arrowSize: 40 }, progressOptions: { showProgressDots: true } };
addPropertyControls(Slideshow, { slots: { type: ControlType.Array, title: "Content", control: { type: ControlType.ComponentInstance } }, direction: { type: ControlType.Enum, title: "Direction", options: ["left", "right", "top", "bottom"], optionIcons: ["direction-left", "direction-right", "direction-up", "direction-down"], optionTitles: ["Left", "Right", "Top", "Bottom"], displaySegmentedControl: true, defaultValue: Slideshow.defaultProps.direction }, autoPlayControl: { type: ControlType.Boolean, title: "Auto Play", defaultValue: true }, intervalControl: { type: ControlType.Number, title: "Interval", defaultValue: 1.5, min: 0.5, max: 10, step: 0.1, displayStepper: true, unit: "s", hidden: (props) => !props.autoPlayControl }, dragControl: { type: ControlType.Boolean, title: "Draggable", defaultValue: false }, startFrom: { type: ControlType.Number, title: "Current", min: 0, max: 10, displayStepper: true, defaultValue: Slideshow.defaultProps.startFrom }, effectsOptions: { type: ControlType.Object, title: "Effects", controls: { effectsOpacity: { type: ControlType.Number, title: "Opacity", defaultValue: Slideshow.defaultProps.effectsOptions.effectsOpacity, min: 0, max: 1, step: 0.01, displayStepper: true }, effectsScale: { type: ControlType.Number, title: "Scale", defaultValue: Slideshow.defaultProps.effectsOptions.effectsScale, min: 0, max: 1, step: 0.01, displayStepper: true }, effectsPerspective: { type: ControlType.Number, title: "Perspective", defaultValue: Slideshow.defaultProps.effectsOptions.effectsPerspective, min: 200, max: 2e3, step: 1 }, effectsRotate: { type: ControlType.Number, title: "Rotate", defaultValue: Slideshow.defaultProps.effectsOptions.effectsRotate, min: -180, max: 180, step: 1 }, effectsHover: { type: ControlType.Boolean, title: "On Hover", enabledTitle: "Play", disabledTitle: "Pause", defaultValue: Slideshow.defaultProps.effectsOptions.effectsHover }, playOffscreen: { type: ControlType.Boolean, title: "Offscreen", enabledTitle: "Play", disabledTitle: "Pause", defaultValue: Slideshow.defaultProps.effectsOptions.playOffscreen } } }, alignment: { type: ControlType.Enum, title: "Align", options: ["flex-start", "center", "flex-end"], optionIcons: { direction: { right: ["align-top", "align-middle", "align-bottom"], left: ["align-top", "align-middle", "align-bottom"], top: ["align-left", "align-center", "align-right"], bottom: ["align-left", "align-center", "align-right"] } }, defaultValue: "center", displaySegmentedControl: true }, itemAmount: { type: ControlType.Number, title: "Items", min: 1, max: 10, displayStepper: true, defaultValue: Slideshow.defaultProps.itemAmount }, gap: { type: ControlType.Number, title: "Gap", min: 0 }, padding: { title: "Padding", type: ControlType.FusedNumber, toggleKey: "paddingPerSide", toggleTitles: ["Padding", "Padding per side"], defaultValue: 0, valueKeys: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"], valueLabels: ["T", "R", "B", "L"], min: 0 }, borderRadius: { type: ControlType.Number, title: "Radius", min: 0, max: 500, displayStepper: true, defaultValue: 0 }, transitionControl: { type: ControlType.Transition, defaultValue: Slideshow.defaultProps.transitionControl, title: "Transition" }, fadeOptions: { type: ControlType.Object, title: "Clipping", controls: { fadeContent: { type: ControlType.Boolean, title: "Fade", defaultValue: false }, overflow: { type: ControlType.Boolean, title: "Overflow", enabledTitle: "Show", disabledTitle: "Hide", defaultValue: false, hidden(props) {
  return props.fadeContent === true;
} }, fadeWidth: { type: ControlType.Number, title: "Width", defaultValue: 25, min: 0, max: 100, unit: "%", hidden(props) {
  return props.fadeContent === false;
} }, fadeInset: { type: ControlType.Number, title: "Inset", defaultValue: 0, min: 0, max: 100, unit: "%", hidden(props) {
  return props.fadeContent === false;
} }, fadeAlpha: { type: ControlType.Number, title: "Opacity", defaultValue: 0, min: 0, max: 1, step: 0.05, hidden(props) {
  return props.fadeContent === false;
} } } }, arrowOptions: { type: ControlType.Object, title: "Arrows", controls: { showMouseControls: { type: ControlType.Boolean, title: "Show", defaultValue: Slideshow.defaultProps.arrowOptions.showMouseControls }, arrowFill: { type: ControlType.Color, title: "Fill", hidden: (props) => !props.showMouseControls, defaultValue: Slideshow.defaultProps.arrowOptions.arrowFill }, leftArrow: { type: ControlType.Image, title: "Previous", hidden: (props) => !props.showMouseControls }, rightArrow: { type: ControlType.Image, title: "Next", hidden: (props) => !props.showMouseControls }, arrowSize: { type: ControlType.Number, title: "Size", min: 0, max: 200, displayStepper: true, defaultValue: Slideshow.defaultProps.arrowOptions.arrowSize, hidden: (props) => !props.showMouseControls }, arrowRadius: { type: ControlType.Number, title: "Radius", min: 0, max: 500, defaultValue: 40, hidden: (props) => !props.showMouseControls }, arrowShouldFadeIn: { type: ControlType.Boolean, title: "Fade In", defaultValue: false, hidden: (props) => !props.showMouseControls }, arrowShouldSpace: { type: ControlType.Boolean, title: "Distance", enabledTitle: "Space", disabledTitle: "Group", defaultValue: Slideshow.defaultProps.arrowOptions.arrowShouldSpace, hidden: (props) => !props.showMouseControls }, arrowPosition: { type: ControlType.Enum, title: "Position", options: ["auto", "top-left", "top-mid", "top-right", "bottom-left", "bottom-mid", "bottom-right"], optionTitles: ["Center", "Top Left", "Top Middle", "Top Right", "Bottom Left", "Bottom Middle", "Bottom Right"], hidden: (props) => !props.showMouseControls || props.arrowShouldSpace }, arrowPadding: { type: ControlType.Number, title: "Inset", min: -100, max: 100, defaultValue: 20, displayStepper: true, hidden: (props) => !props.showMouseControls || !props.arrowShouldSpace }, arrowPaddingTop: { type: ControlType.Number, title: "Top", min: -500, max: 500, defaultValue: 0, displayStepper: true, hidden: (props) => !props.showMouseControls || props.arrowShouldSpace || props.arrowPosition === "auto" || props.arrowPosition === "bottom-mid" || props.arrowPosition === "bottom-left" || props.arrowPosition === "bottom-right" }, arrowPaddingBottom: { type: ControlType.Number, title: "Bottom", min: -500, max: 500, defaultValue: 0, displayStepper: true, hidden: (props) => !props.showMouseControls || props.arrowShouldSpace || props.arrowPosition === "auto" || props.arrowPosition === "top-mid" || props.arrowPosition === "top-left" || props.arrowPosition === "top-right" }, arrowPaddingRight: { type: ControlType.Number, title: "Right", min: -500, max: 500, defaultValue: 0, displayStepper: true, hidden: (props) => !props.showMouseControls || props.arrowShouldSpace || props.arrowPosition === "auto" || props.arrowPosition === "top-left" || props.arrowPosition === "top-mid" || props.arrowPosition === "bottom-left" || props.arrowPosition === "bottom-mid" }, arrowPaddingLeft: { type: ControlType.Number, title: "Left", min: -500, max: 500, defaultValue: 0, displayStepper: true, hidden: (props) => !props.showMouseControls || props.arrowShouldSpace || props.arrowPosition === "auto" || props.arrowPosition === "top-right" || props.arrowPosition === "top-mid" || props.arrowPosition === "bottom-right" || props.arrowPosition === "bottom-mid" }, arrowGap: { type: ControlType.Number, title: "Gap", min: 0, max: 100, defaultValue: 10, displayStepper: true, hidden: (props) => !props.showMouseControls || props.arrowShouldSpace } } }, progressOptions: { type: ControlType.Object, title: "Dots", controls: { showProgressDots: { type: ControlType.Boolean, title: "Show", defaultValue: false }, dotSize: { type: ControlType.Number, title: "Size", min: 1, max: 100, defaultValue: 10, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsInset: { type: ControlType.Number, title: "Inset", min: -100, max: 100, defaultValue: 10, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsGap: { type: ControlType.Number, title: "Gap", min: 0, max: 100, defaultValue: 10, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsPadding: { type: ControlType.Number, title: "Padding", min: 0, max: 100, defaultValue: 10, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsFill: { type: ControlType.Color, title: "Fill", defaultValue: "#fff", hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsBackground: { type: ControlType.Color, title: "Backdrop", defaultValue: "rgba(0,0,0,0.2)", hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsRadius: { type: ControlType.Number, title: "Radius", min: 0, max: 200, defaultValue: 50, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsOpacity: { type: ControlType.Number, title: "Opacity", min: 0, max: 1, defaultValue: 0.5, step: 0.1, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsActiveOpacity: { type: ControlType.Number, title: "Current", min: 0, max: 1, defaultValue: 1, step: 0.1, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsBlur: { type: ControlType.Number, title: "Blur", min: 0, max: 50, defaultValue: 0, step: 1, hidden: (props) => !props.showProgressDots || props.showScrollbar } } } });
// Framer UI에서 편집 가능한 모든 속성(Property Controls)을 정의합니다.

var containerStyle = { display: "flex", flexDirection: "row", width: "100%", height: "100%", maxWidth: "100%", maxHeight: "100%", placeItems: "center", margin: 0, padding: 0, listStyleType: "none", textIndent: "none" };
var placeholderStyles = { display: "flex", width: "100%", height: "100%", placeContent: "center", placeItems: "center", flexDirection: "column", color: "#96F", background: "rgba(136, 85, 255, 0.1)", fontSize: 11, overflow: "hidden", padding: "20px 20px 30px 20px" };
var emojiStyles = { fontSize: 32, marginBottom: 10 };
var titleStyles = { margin: 0, marginBottom: 10, fontWeight: 600, textAlign: "center" };
var subtitleStyles = { margin: 0, opacity: 0.7, maxWidth: 180, lineHeight: 1.5, textAlign: "center" };
var baseButtonStyles = { border: "none", display: "flex", placeContent: "center", placeItems: "center", overflow: "hidden", background: "transparent", cursor: "pointer", margin: 0, padding: 0 };
var controlsStyles = { display: "flex", justifyContent: "space-between", alignItems: "center", position: "absolute", pointerEvents: "none", userSelect: "none", top: 0, left: 0, right: 0, bottom: 0, border: 0, padding: 0, margin: 0 };
var clamp = (num, min, max) => Math.min(Math.max(num, min), max);
// 스타일 객체 및 헬퍼 함수 정의

var Slide = /* @__PURE__ */ memo(/* @__PURE__ */ forwardRef(function Component(props, ref) {
// 개별 슬라이드 컴포넌트 정의

  const {
    slideKey,
    width,
    height,
    child,
    size,
    gap,
    wrappedValue,
    numChildren,
    childCounter,
    isCanvas,
    effects,
    effectsOpacity,
    effectsScale,
    effectsRotate,
    isHorizontal,
    isLast,
    index,
    /** 1 or -1 depending on if horizontal and rtl writing direction */
    directionModifier
  } = props;
  const fallbackRef = useRef();
  const childOffset = (size?.item + gap) * childCounter;
  const scrollRange = [-size?.item, 0, size?.parent - size?.item + gap, size?.parent].map((val) => val - childOffset * directionModifier);
// 스크롤 위치에 따른 애니메이션 범위를 계산합니다. 이는 3D 효과의 핵심입니다.

  const rotateY = !isCanvas && useTransform(wrappedValue, scrollRange, [-effectsRotate, 0, 0, effectsRotate]);
  const rotateX = !isCanvas && useTransform(wrappedValue, scrollRange, [effectsRotate, 0, 0, -effectsRotate]);
  const opacity = !isCanvas && useTransform(wrappedValue, scrollRange, [effectsOpacity, 1, 1, effectsOpacity]);
  const scale = !isCanvas && useTransform(wrappedValue, scrollRange, [effectsScale, 1, 1, effectsScale]);
  const originXorY = !isCanvas && useTransform(wrappedValue, scrollRange, [1, 1, 0, 0]);
  const isVisible = !isCanvas && useTransform(wrappedValue, (latest) => latest >= scrollRange[1] && latest <= scrollRange[2]);
// wrappedValue (슬라이드 컨테이너의 실시간 모션 값)를 사용하여 각 슬라이드의 회전, 불투명도, 크기 등의 애니메이션 속성을 변환(useTransform)합니다.

  useEffect(() => {
    if (!isVisible) return;
    function manageVisibility(visible) {
      const node = ref?.current ?? fallbackRef.current;
      if (!node) return;
      if (visible) {
        node.querySelectorAll("button,a").forEach((el) => {
          const orig = el.dataset.origTabIndex;
          if (orig) el.tabIndex = orig;
          else el.removeAttribute("tabIndex");
        });
      } else {
        node.querySelectorAll("button,a").forEach((el) => {
          const orig = el.getAttribute("tabIndex");
          if (orig) el.dataset.origTabIndex = orig;
          el.tabIndex = -1;
        });
      }
      node.setAttribute("aria-hidden", !visible);
    }
    manageVisibility(isVisible);
    return isVisible.on("change", (visible) => {
      manageVisibility(visible);
    });
  }, []);
// 접근성(Accessibility) 관리 로직: 슬라이드가 보이지 않을 때 내부 요소(버튼, 링크)의 `tabIndex`를 -1로 설정하여 포커스되는 것을 방지합니다.

  const visibility = isCanvas ? "visible" : useTransform(wrappedValue, [scrollRange[0] - size.viewportLength, mix(scrollRange[1], scrollRange[2], 0.5), scrollRange[3] + size.viewportLength], ["hidden", "visible", "hidden"]);
// 뷰포트 바깥에 있는 슬라이드를 숨겨서 성능을 최적화합니다.

  const key = slideKey + "child";
  return /* @__PURE__ */ _jsx(LayoutGroup, { inherit: "id", id: key, children: /* @__PURE__ */ _jsx("li", { style: { display: "contents" }, children: /* @__PURE__ */ cloneElement(child, { ref: ref ?? fallbackRef, key, style: { ...child.props?.style, flexShrink: 0, userSelect: "none", width, height, opacity, scale, originX: isHorizontal ? originXorY : 0.5, originY: !isHorizontal ? originXorY : 0.5, rotateY: isHorizontal ? rotateY : 0, rotateX: !isHorizontal ? rotateX : 0, visibility }, layoutId: child.props.layoutId ? child.props.layoutId + "-original-" + index : void 0 }) }) });
// 래핑된 슬라이드(`li`)와 애니메이션 속성이 적용된 자식 요소(`motion` 컴포넌트)를 렌더링합니다.

}));
var Dot = /* @__PURE__ */ memo(function Dot2({ selectedOpacity, opacity, total, index, wrappedIndex, wrappedIndexInverted, dotStyle: dotStyle2, buttonStyle, gap, padding, isHorizontal, isInverted, ...props }) {
  let isSelected = wrappedIndex === index;
  if (isInverted) {
    isSelected = Math.abs(wrappedIndexInverted) === index;
  }
// 현재 페이지에 해당하는지 확인합니다.

  const inlinePadding = gap / 2;
  const top = !isHorizontal && index > 0 ? inlinePadding : padding;
  const bottom = !isHorizontal && index !== total - 1 ? inlinePadding : padding;
  const right = isHorizontal && index !== total - 1 ? inlinePadding : padding;
  const left = isHorizontal && index > 0 ? inlinePadding : padding;
// 닷(Dot) 사이의 간격과 패딩을 계산합니다.

  return /* @__PURE__ */ _jsx("button", { "aria-label": `Scroll to page ${index + 1}`, type: "button", ...props, style: { ...buttonStyle, padding: `${top}px ${right}px ${bottom}px ${left}px` }, children: /* @__PURE__ */ _jsx(motion.div, { style: { ...dotStyle2 }, initial: false, animate: { opacity: isSelected ? selectedOpacity : opacity }, transition: { duration: 0.3 } }) });
// 페이지네이션 점을 렌더링하고, 선택된 점의 불투명도를 애니메이션합니다.

});
var dotsContainerStyle = { display: "flex", placeContent: "center", placeItems: "center", overflow: "hidden", position: "absolute", pointerEvents: "auto" };
var dotStyle = { borderRadius: "50%", background: "white", cursor: "pointer", border: "none", placeContent: "center", placeItems: "center", padding: 0 };
function useWritingDirection() {
// 문서의 쓰기 방향(`ltr` 또는 `rtl`)을 감지하는 훅입니다.
  const [writingDirection, setWritingDirection] = useState("ltr");
  useEffect(() => {
    if (window?.document?.documentElement?.dir === "rtl") {
      setWritingDirection("rtl");
    }
  }, []);
  return writingDirection;
}
function getSlideshowResolvedDirection(direction, writingDirection) {
// 쓰기 방향(`rtl`)에 따라 `left`와 `right` 슬라이드 방향을 반전시키는 헬퍼 함수입니다.
  if (writingDirection !== "rtl") return direction;
  if (direction === "left") return "right";
  if (direction === "right") return "left";
  return direction;
}

export {
  Slideshow
};
// 메인 컴포넌트를 내보냅니다.